<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keyword Prompt Builder</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;
    const { createRoot } = ReactDOM;

    // Dữ liệu JSON mẫu (fallback nếu không tải được keywords.json)
    const SAMPLE_JSON = {
      "category": {
        "subCategory1": ["value1", "value2"],
        "subCategory2": {
          "nested1": ["value1", "value2"],
          "nested2": ["value1", "value2"]
        }
      }
    };

    // Helper types
    type JSONValue = string | number | boolean | null | { [key: string]: JSONValue } | JSONValue[];
    type SelectionMap = Record<string, Set<string>>;

    // Utils
    const DEFAULT_JOINER = ", ";

    function flattenEntries(obj, basePath = []) {
      const out = [];
      if (Array.isArray(obj)) {
        obj.forEach((v, i) => {
          if (typeof v !== "object" || v === null) {
            out.push({ path: basePath, label: String(v), value: String(v), kind: "item" });
          } else {
            out.push(...flattenEntries(v, basePath));
          }
        });
      } else if (obj && typeof obj === "object") {
        Object.entries(obj).forEach(([k, v]) => {
          const newPath = [...basePath, k];
          out.push({ path: newPath, label: k, kind: "group" });
          out.push(...flattenEntries(v, newPath));
        });
      }
      return out;
    }

    function pathKey(path) { return path.join("."); }

    function ensureSet(map, key) {
      if (!map[key]) map[key] = new Set();
      return map[key];
    }

    function countTokensApprox(text) {
      return Math.ceil(text.trim().length / 4);
    }

    // UI Components
    const Button = ({ className = "", ...props }) => (
      <button
        className={`px-3 py-2 rounded-2xl bg-indigo-600 text-white hover:bg-indigo-700 active:scale-[.99] shadow-sm transition ${className}`}
        {...props}
      />
    );

    const Card = ({ className = "", ...props }) => (
      <div className={`rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-white/70 dark:bg-zinc-900/70 shadow-sm ${className}`} {...props} />
    );

    const Checkbox = ({ checked, onChange, disabled }) => (
      <label className={`inline-flex items-center gap-2 select-none cursor-pointer ${disabled ? "opacity-50 cursor-not-allowed" : ""}`}>
        <input type="checkbox" className="size-4 accent-indigo-600" checked={!!checked} onChange={e => onChange?.(e.target.checked)} disabled={disabled} />
      </label>
    );

    const Switch = ({ checked, onChange }) => (
      <button onClick={() => onChange(!checked)} className={`w-12 h-7 rounded-full p-1 transition ${checked ? "bg-indigo-600" : "bg-zinc-300 dark:bg-zinc-700"}`}>
        <span className={`block w-5 h-5 bg-white rounded-full transition ${checked ? "translate-x-5" : ""}`} />
      </button>
    );

    const Badge = ({ children }) => (
      <span className="inline-flex items-center gap-1 text-xs px-2 py-1 rounded-full border border-zinc-200 dark:border-zinc-700 bg-zinc-50 dark:bg-zinc-800">{children}</span>
    );

    const GroupBlock = ({ title, children, right, defaultOpen }) => {
      const [open, setOpen] = useState(!!defaultOpen);
      return (
        <div className="rounded-2xl border border-zinc-200 dark:border-zinc-800 overflow-hidden">
          <button onClick={() => setOpen(o => !o)} className="w-full flex items-center justify-between gap-3 px-4 py-3 bg-zinc-50 dark:bg-zinc-900 text-left">
            <div className="font-semibold">{title}</div>
            <div className="flex items-center gap-3">
              {right}
              <span className={`transition inline-block text-zinc-500 ${open ? "rotate-180" : ""}`}>▾</span>
            </div>
          </button>
          {open && <div className="p-4">{children}</div>}
        </div>
      );
    };

    const ItemsGrid = ({ items, groupKey, selections, onToggle }) => {
      const chosen = selections[groupKey] || new Set();
      return (
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
          {items.map(label => {
            const checked = chosen.has(label);
            return (
              <label
                key={label}
                className={`flex items-center gap-2 px-2 py-1 rounded-xl border text-sm cursor-pointer select-none ${
                  checked ? "border-indigo-500 bg-indigo-50 dark:bg-indigo-950/30" : "border-zinc-200 dark:border-zinc-800 hover:bg-zinc-50 dark:hover:bg-zinc-900"
                }`}
              >
                <input type="checkbox" className="size-4 accent-indigo-600" checked={checked} onChange={e => onToggle(groupKey, label, e.target.checked)} />
                <span>{label}</span>
              </label>
            );
          })}
        </div>
      );
    };

    const Toolbar = ({ joiner, setJoiner, showLabels, setShowLabels, onlySelected, setOnlySelected, onClearAll, onSelectAllInView }) => (
      <div className="flex flex-wrap items-center gap-3">
        <div className="flex items-center gap-2">
          <span className="text-sm text-zinc-500">Join by</span>
          <input
            value={joiner}
            onChange={e => setJoiner(e.target.value)}
            className="px-2 py-1 rounded-xl border border-zinc-200 dark:border-zinc-800 bg-transparent w-28"
          />
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-zinc-500">Show group labels</span>
          <Switch checked={showLabels} onChange={setShowLabels} />
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-zinc-500">Only selected groups</span>
          <Switch checked={onlySelected} onChange={setOnlySelected} />
        </div>
        <div className="ml-auto flex items-center gap-2">
          <Button className="bg-zinc-200 text-zinc-900 hover:bg-zinc-300" onClick={onSelectAllInView}>Select all in view</Button>
          <Button className="bg-rose-600 hover:bg-rose-700" onClick={onClearAll}>Clear all</Button>
        </div>
      </div>
    );

    // Main App
    const App = () => {
      const [raw, setRaw] = useState(null);
      const [error, setError] = useState(null);
      const [query, setQuery] = useState("");
      const [joiner, setJoiner] = useState(DEFAULT_JOINER);
      const [showLabels, setShowLabels] = useState(true);
      const [onlySelected, setOnlySelected] = useState(false);
      const [selections, setSelections] = useState(() => {
        const saved = localStorage.getItem("kp_selections");
        return saved ? Object.fromEntries(Object.entries(JSON.parse(saved)).map(([k, arr]) => [k, new Set(arr)])) : {};
      });

      // Tải keywords.json từ repository
      useEffect(() => {
        fetch("./keywords.json", { cache: "no-store" })
          .then(response => {
            if (!response.ok) throw new Error(`Failed to load keywords.json (${response.status})`);
            return response.text(); // Get raw text for debugging
          })
          .then(text => {
            console.log("Raw JSON content:", text); // Debug log
            return JSON.parse(text);
          })
          .then(data => setRaw(data))
          .catch(err => {
            console.warn("Could not load keywords.json, falling back to sample data:", err.message);
            setRaw(SAMPLE_JSON);
            setError(err.message);
          });
      }, []);

      useEffect(() => {
        const json = Object.fromEntries(Object.entries(selections).map(([k, s]) => [k, Array.from(s)]));
        localStorage.setItem("kp_selections", JSON.stringify(json));
      }, [selections]);

      const groups = useMemo(() => {
        if (!raw) return [];
        const out = [];
        function collect(node, prefix) {
          if (Array.isArray(node)) {
            const items = node.filter(v => typeof v !== "object").map(String);
            if (items.length) out.push({ title: prefix[prefix.length - 1] || "items", items, key: pathKey(prefix) });
            node.forEach(v => { if (v && typeof v === "object") collect(v, prefix); });
          } else if (node && typeof node === "object") {
            Object.entries(node).forEach(([k, v]) => {
              const p = [...prefix, k];
              if (Array.isArray(v)) {
                const items = v.filter(it => typeof it !== "object").map(String);
                if (items.length) out.push({ title: k, items, key: pathKey(p) });
                v.forEach(it => { if (it && typeof it === "object") collect(it, p); });
              } else if (v && typeof v === "object") {
                collect(v, p);
              }
            });
          }
        }
        collect(raw, []);
        const merged = new Map();
        out.forEach(g => {
          const exist = merged.get(g.key);
          if (!exist) merged.set(g.key, { title: g.title, items: new Set(g.items), key: g.key });
          else g.items.forEach(i => exist.items.add(i));
        });
        return Array.from(merged.values()).map(m => ({ title: m.title, items: Array.from(m.items).sort(), key: m.key }));
      }, [raw]);

      const filteredGroups = useMemo(() => {
        const q = query.trim().toLowerCase();
        const result = groups.filter(g => {
          if (onlySelected) {
            const set = selections[g.key];
            if (!set || set.size === 0) return false;
          }
          if (!q) return true;
          return g.title.toLowerCase().includes(q) || g.items.some(it => it.toLowerCase().includes(q));
        });
        return result.sort((a, b) => {
          const sa = (selections[a.key]?.size || 0);
          const sb = (selections[b.key]?.size || 0);
          if (sa !== sb) return sb - sa;
          return a.title.localeCompare(b.title);
        });
      }, [groups, query, selections, onlySelected]);

      function toggleItem(groupKey, item, checked) {
        setSelections(prev => {
          const copy = { ...prev };
          const set = ensureSet(copy, groupKey);
          if (checked) set.add(item); else set.delete(item);
          return { ...copy };
        });
      }

      function selectAllInView() {
        setSelections(prev => {
          const copy = { ...prev };
          filteredGroups.forEach(g => {
            const set = ensureSet(copy, g.key);
            g.items.forEach(it => set.add(it));
          });
          return { ...copy };
        });
      }

      function clearAll() { setSelections({}); }

      const prompt = useMemo(() => {
        const parts = [];
        groups.forEach(g => {
          const chosen = selections[g.key];
          if (!chosen || chosen.size === 0) return;
          const items = Array.from(chosen);
          const segment = showLabels ? `${g.title}: ${items.join(joiner)}` : items.join(joiner);
          parts.push(segment);
        });
        return parts.join("; ");
      }, [groups, selections, joiner, showLabels]);

      const tokenApprox = useMemo(() => countTokensApprox(prompt), [prompt]);

      function copyPrompt() {
        navigator.clipboard.writeText(prompt).then(() => {
          alert("Prompt copied to clipboard ✓");
        });
      }

      function savePreset() {
        const json = Object.fromEntries(Object.entries(selections).map(([k, s]) => [k, Array.from(s)]));
        const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'prompt-preset.json'; a.click();
        URL.revokeObjectURL(url);
      }

      function loadPresetFromFile(file) {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const obj = JSON.parse(String(reader.result));
            const map = Object.fromEntries(Object.entries(obj).map(([k, arr]) => [k, new Set(arr)]));
            setSelections(map);
          } catch (e) { alert("Invalid preset file."); }
        };
        reader.readAsText(file);
      }

      function importKeywordsFromFile(file) {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            setRaw(JSON.parse(String(reader.result)));
            setError(null);
          } catch (e) { alert("Invalid JSON file."); }
        };
        reader.readAsText(file);
      }

      return (
        <div className="min-h-screen bg-gradient-to-b from-white to-zinc-50 dark:from-zinc-950 dark:to-zinc-900 text-zinc-900 dark:text-zinc-100">
          <div className="max-w-7xl mx-auto px-4 py-6 md:py-10">
            <header className="flex flex-wrap items-center gap-4 mb-6">
              <h1 className="text-2xl md:text-3xl font-bold">Keyword Prompt Builder</h1>
              <Badge>Loaded from keywords.json</Badge>
              {error && <span className="text-rose-600">(Fallback to sample data: {error})</span>}
              <div className="ml-auto flex items-center gap-2">
                <input
                  placeholder="Search groups/keywords..."
                  value={query}
                  onChange={e => setQuery(e.target.value)}
                  className="px-3 py-2 rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-transparent w-64"
                />
                <Button onClick={copyPrompt}>Copy Prompt</Button>
              </div>
            </header>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              <div className="lg:col-span-1 space-y-4">
                <Card className="p-4 space-y-4">
                  <h2 className="font-semibold">Prompt Settings</h2>
                  <Toolbar
                    joiner={joiner}
                    setJoiner={setJoiner}
                    showLabels={showLabels}
                    setShowLabels={setShowLabels}
                    onlySelected={onlySelected}
                    setOnlySelected={setOnlySelected}
                    onClearAll={clearAll}
                    onSelectAllInView={selectAllInView}
                  />
                </Card>
                <Card className="p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <h2 className="font-semibold">Prompt Preview</h2>
                    <Badge>{tokenApprox} tokens ~ (estimated)</Badge>
                  </div>
                  <textarea
                    value={prompt}
                    readOnly
                    rows={10}
                    className="w-full rounded-xl border border-zinc-200 dark:border-zinc-800 bg-transparent p-3 text-sm"
                  />
                  <div className="flex items-center gap-2">
                    <Button onClick={copyPrompt}>Copy</Button>
                    <Button className="bg-zinc-200 text-zinc-900 hover:bg-zinc-300" onClick={savePreset}>Save Preset</Button>
                    <label className="cursor-pointer px-3 py-2 rounded-2xl border border-zinc-200 dark:border-zinc-800">
                      Load Preset
                      <input hidden type="file" accept="application/json" onChange={e => { const f = e.target.files?.[0]; if (f) loadPresetFromFile(f); }} />
                    </label>
                  </div>
                </Card>
                <Card className="p-4 space-y-3">
                  <h2 className="font-semibold">Keyword Source</h2>
                  <p className="text-sm text-zinc-500">Upload a keywords.json file to replace the default keywords.</p>
                  <label className="cursor-pointer w-full text-center px-3 py-2 rounded-2xl border border-dashed border-zinc-300 dark:border-zinc-700 hover:bg-zinc-50 dark:hover:bg-zinc-900">
                    Import keywords.json
                    <input hidden type="file" accept="application/json" onChange={e => { const f = e.target.files?.[0]; if (f) importKeywordsFromFile(f); }} />
                  </label>
                </Card>
              </div>
              <div className="lg:col-span-2 space-y-4">
                {filteredGroups.map(g => {
                  const set = selections[g.key] || new Set();
                  const allChecked = set.size > 0 && set.size === g.items.length;
                  const someChecked = set.size > 0 && set.size < g.items.length;
                  return (
                    <GroupBlock
                      key={g.key}
                      title={`${g.title} ${set.size ? `(${set.size})` : ""}`}
                      defaultOpen={set.size > 0}
                      right={
                        <div className="flex items-center gap-2">
                          {someChecked && <Badge>partial</Badge>}
                          <label className="flex items-center gap-2 text-sm">
                            <span>Select all</span>
                            <Checkbox
                              checked={allChecked}
                              onChange={v => {
                                setSelections(prev => {
                                  const copy = { ...prev };
                                  const s = ensureSet(copy, g.key);
                                  if (v) g.items.forEach(it => s.add(it)); else s.clear();
                                  return { ...copy };
                                });
                              }}
                            />
                          </label>
                        </div>
                      }
                    >
                      <ItemsGrid items={g.items} groupKey={g.key} selections={selections} onToggle={toggleItem} />
                    </GroupBlock>
                  );
                })}
                {filteredGroups.length === 0 && (
                  <Card className="p-6 text-center text-zinc-500">No groups match the current search or filter.</Card>
                )}
              </div>
            </div>
            <footer className="mt-10 text-center text-xs text-zinc-500">
              <div>Made with ❤️ – Supports nested JSON, works offline after loading.</div>
            </footer>
          </div>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
