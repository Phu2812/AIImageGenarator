import React, { useEffect, useMemo, useState } from "react";

// üß© Keyword Prompt Builder ‚Äì ƒë·ªçc JSON c√πng th∆∞ m·ª•c v√† t·∫°o prompt gen ·∫£nh
// C√°ch d√πng (deploy c·ª±c nhanh):
// 1) T·∫°o 2 file trong c√πng th∆∞ m·ª•c: 
//    - index.html (ƒë∆∞·ª£c build t·ª´ d·ª± √°n React n√†y) 
//    - keywords.json (ch√≠nh l√† file JSON b·∫°n g·ª≠i ·ªü tr√™n)
// 2) ·ª®ng d·ª•ng s·∫Ω t·ª± fetch("./keywords.json") khi t·∫£i trang.
// 3) Ng∆∞·ªùi d√πng tick ch·ªçn keyword ƒë·ªÉ t·∫°o prompt, copy 1 ch·∫°m.
//
// ‚úÖ T√≠nh nƒÉng n·ªïi b·∫≠t:
// - T·ª± ƒë·ªông ƒë·ªçc keywords.json ·ªü c√πng th∆∞ m·ª•c (c√≥ fallback Import file th·ªß c√¥ng)
// - Hi·ªÉn th·ªã d·∫°ng nh√≥m/accordion, h·ªó tr·ª£ l·ªìng s√¢u (object trong object/array)
// - T√¨m ki·∫øm nhanh theo t·ª´ kho√°
// - Multi-select, Ch·ªçn/B·ªè ch·ªçn nh√≥m
// - B·ªô l·ªçc: ch·ªâ m·ª•c ƒë√£ ch·ªçn / t·∫•t c·∫£
// - Tu·ª≥ ch·ªânh joiner, c√≥/kh√¥ng nh√£n danh m·ª•c, th·ª© t·ª± nh√≥m
// - Copy prompt, ƒë·∫øm token (x·∫•p x·ªâ), l∆∞u/kh√¥i ph·ª•c preset (localStorage)
// - H·ªó tr·ª£ dark mode theo h·ªá th·ªëng
//
// ‚ö†Ô∏è L∆∞u √Ω: n·∫øu ch·∫°y file tƒ©nh tr√™n file:// th√¨ fetch c√≥ th·ªÉ b·ªã ch·∫∑n do CORS. H√£y d√πng m·ªôt web server tƒ©nh
// (vd: npx serve, vite preview, ho·∫∑c upload l√™n hosting).

// ----------------------------- Helper types -----------------------------

type JSONValue = string | number | boolean | null | JSONObject | JSONArray;
interface JSONObject { [key: string]: JSONValue }
interface JSONArray extends Array<JSONValue> {}

type SelectionMap = Record<string, Set<string>>; // key: groupPath, values selected

// ----------------------------- UI Primitives (thu·∫ßn Tailwind) -----------------------------

function Button({ className = "", ...props }: React.ButtonHTMLAttributes<HTMLButtonElement>) {
  return (
    <button
      className={`px-3 py-2 rounded-2xl bg-indigo-600 text-white hover:bg-indigo-700 active:scale-[.99] shadow-sm transition ${className}`}
      {...props}
    />
  );
}

function Card({ className = "", ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={`rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-white/70 dark:bg-zinc-900/70 shadow-sm ${className}`} {...props} />
}

function Checkbox({ checked, onChange, disabled }: { checked?: boolean, onChange?: (v:boolean)=>void, disabled?: boolean }) {
  return (
    <label className={`inline-flex items-center gap-2 select-none cursor-pointer ${disabled?"opacity-50 cursor-not-allowed":""}`}>
      <input type="checkbox" className="size-4 accent-indigo-600" checked={!!checked} onChange={e=>onChange?.(e.target.checked)} disabled={disabled} />
    </label>
  )
}

function Switch({ checked, onChange }: { checked: boolean, onChange: (v:boolean)=>void }){
  return (
    <button onClick={()=>onChange(!checked)} className={`w-12 h-7 rounded-full p-1 transition ${checked?"bg-indigo-600":"bg-zinc-300 dark:bg-zinc-700"}`}>
      <span className={`block w-5 h-5 bg-white rounded-full transition ${checked?"translate-x-5":""}`} />
    </button>
  )
}

function Badge({ children }: { children: React.ReactNode }){
  return <span className="inline-flex items-center gap-1 text-xs px-2 py-1 rounded-full border border-zinc-200 dark:border-zinc-700 bg-zinc-50 dark:bg-zinc-800">{children}</span>
}

// ----------------------------- Utils -----------------------------

const DEFAULT_JOINER = ", ";

function flattenEntries(obj: JSONValue, basePath: string[] = []): { path: string[], label: string, value?: string, kind: "group"|"item" }[] {
  const out: { path: string[], label: string, value?: string, kind: "group"|"item" }[] = [];
  if (Array.isArray(obj)) {
    // array of strings or nested
    obj.forEach(v => {
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
        out.push({ path: basePath, label: String(v), value: String(v), kind: "item" })
      } else if (v && typeof v === "object") {
        // uncommon, but handle array of objects
        const idx = out.length;
        out.push({ path: basePath, label: `item_${idx}`, kind: "group" });
        out.push(...flattenEntries(v as JSONObject, basePath));
      }
    });
  } else if (obj && typeof obj === "object") {
    Object.entries(obj as JSONObject).forEach(([k, v]) => {
      const newPath = [...basePath, k];
      if (Array.isArray(v)) {
        out.push({ path: newPath, label: k, kind: "group" });
        v.forEach(it => {
          if (typeof it === "string" || typeof it === "number" || typeof it === "boolean") {
            out.push({ path: newPath, label: String(it), value: String(it), kind: "item" })
          } else if (it && typeof it === "object") {
            // nested object inside array (rare) -> treat as subgroup
            out.push({ path: newPath, label: k, kind: "group" });
            out.push(...flattenEntries(it as JSONObject, newPath));
          }
        })
      } else if (v && typeof v === "object") {
        out.push({ path: newPath, label: k, kind: "group" });
        out.push(...flattenEntries(v as JSONObject, newPath));
      }
    })
  }
  return out;
}

function pathKey(path: string[]) { return path.join("."); }

function ensureSet(map: SelectionMap, key: string) {
  if (!map[key]) map[key] = new Set<string>();
  return map[key];
}

function countTokensApprox(text: string){
  // x·∫•p x·ªâ: 1 token ~ 4 k√Ω t·ª± latin (r·∫•t th√¥, ch·ªâ ƒë·ªÉ tham kh·∫£o)
  const len = text.trim().length;
  return Math.ceil(len / 4);
}

// ----------------------------- Components -----------------------------

const GroupBlock: React.FC<{
  title: string,
  children?: React.ReactNode,
  right?: React.ReactNode,
  defaultOpen?: boolean
}> = ({ title, children, right, defaultOpen }) => {
  const [open, setOpen] = useState(!!defaultOpen);
  return (
    <div className="rounded-2xl border border-zinc-200 dark:border-zinc-800 overflow-hidden">
      <button onClick={()=>setOpen(o=>!o)} className="w-full flex items-center justify-between gap-3 px-4 py-3 bg-zinc-50 dark:bg-zinc-900 text-left">
        <div className="font-semibold">{title}</div>
        <div className="flex items-center gap-3">
          {right}
          <span className={`i ${open?"rotate-180":""} transition inline-block text-zinc-500`}>‚ñæ</span>
        </div>
      </button>
      {open && (
        <div className="p-4">
          {children}
        </div>
      )}
    </div>
  )
}

const ItemsGrid: React.FC<{ items: string[], groupKey: string, selections: SelectionMap, onToggle: (groupKey:string, item:string, checked:boolean)=>void }>
= ({ items, groupKey, selections, onToggle }) => {
  const chosen = selections[groupKey] || new Set<string>();
  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
      {items.map((label) => {
        const checked = chosen.has(label);
        return (
          <label key={label} className={`flex items-center gap-2 px-2 py-1 rounded-xl border text-sm cursor-pointer select-none ${checked?"border-indigo-500 bg-indigo-50 dark:bg-indigo-950/30":"border-zinc-200 dark:border-zinc-800 hover:bg-zinc-50 dark:hover:bg-zinc-900"}`}>
            <input type="checkbox" className="size-4 accent-indigo-600" checked={checked} onChange={e=>onToggle(groupKey, label, e.target.checked)} />
            <span>{label}</span>
          </label>
        )
      })}
    </div>
  )
}

const Toolbar: React.FC<{
  joiner: string, setJoiner: (v:string)=>void,
  showLabels: boolean, setShowLabels: (v:boolean)=>void,
  onlySelected: boolean, setOnlySelected: (v:boolean)=>void,
  onClearAll: ()=>void, onSelectAllInView: ()=>void,
}> = ({ joiner, setJoiner, showLabels, setShowLabels, onlySelected, setOnlySelected, onClearAll, onSelectAllInView }) => {
  return (
    <div className="flex flex-wrap items-center gap-3">
      <div className="flex items-center gap-2">
        <span className="text-sm text-zinc-500">N·ªëi b·∫±ng</span>
        <input value={joiner} onChange={e=>setJoiner(e.target.value)} className="px-2 py-1 rounded-xl border border-zinc-200 dark:border-zinc-800 bg-transparent w-28" />
      </div>
      <div className="flex items-center gap-2">
        <span className="text-sm text-zinc-500">Hi·ªán nh√£n nh√≥m</span>
        <Switch checked={showLabels} onChange={setShowLabels} />
      </div>
      <div className="flex items-center gap-2">
        <span className="text-sm text-zinc-500">Ch·ªâ nh√≥m c√≥ ch·ªçn</span>
        <Switch checked={onlySelected} onChange={setOnlySelected} />
      </div>
      <div className="ml-auto flex items-center gap-2">
        <Button className="bg-zinc-200 text-zinc-900 hover:bg-zinc-300" onClick={onSelectAllInView}>Ch·ªçn t·∫•t c·∫£ trong khung</Button>
        <Button className="bg-rose-600 hover:bg-rose-700" onClick={onClearAll}>B·ªè ch·ªçn h·∫øt</Button>
      </div>
    </div>
  )
}

// ----------------------------- Main App -----------------------------

export default function App(){
  const [raw, setRaw] = useState<JSONObject | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [query, setQuery] = useState("");
  const [joiner, setJoiner] = useState(DEFAULT_JOINER);
  const [showLabels, setShowLabels] = useState(true);
  const [onlySelected, setOnlySelected] = useState(false);
  const [selections, setSelections] = useState<SelectionMap>(() => {
    const saved = localStorage.getItem("kp_selections");
    return saved ? Object.fromEntries(Object.entries(JSON.parse(saved)).map(([k, arr])=>[k, new Set(arr as string[])])) : {};
  });

  // T·∫£i keywords.json
  useEffect(()=>{
    fetch("./keywords.json", { cache: "no-store" })
      .then(r=>{ if(!r.ok) throw new Error(`Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c keywords.json (${r.status})`); return r.json(); })
      .then((data)=> setRaw(data))
      .catch((e)=> setError(e.message));
  },[]);

  // L∆∞u selections
  useEffect(()=>{
    const json = Object.fromEntries(Object.entries(selections).map(([k, s])=>[k, Array.from(s)]));
    localStorage.setItem("kp_selections", JSON.stringify(json));
  }, [selections])

  const groups = useMemo(()=>{
    if(!raw) return [] as { title: string, items: string[], key: string }[];
    // L·∫•y t·∫•t c·∫£ nh√≥m top-level (object keys). N·∫øu gi√° tr·ªã l√† object/array s√¢u, gom item l√°
    const out: { title: string, items: string[], key: string }[] = [];

    function collect(node: JSONValue, prefix: string[]){
      if (Array.isArray(node)){
        const items: string[] = [];
        node.forEach(v=>{ if(typeof v!=="object") items.push(String(v)); });
        if (items.length){ out.push({ title: prefix[prefix.length-1] || "items", items, key: pathKey(prefix) }); }
        node.forEach(v=>{ if (v && typeof v === "object") collect(v as JSONObject, prefix); });
      } else if (node && typeof node === "object"){
        Object.entries(node).forEach(([k, v]) => {
          const p = [...prefix, k];
          if (Array.isArray(v)){
            const items: string[] = [];
            v.forEach(it=>{ if(typeof it!=="object") items.push(String(it)); });
            out.push({ title: k, items, key: pathKey(p) });
            v.forEach(it=>{ if (it && typeof it === "object") collect(it as JSONObject, p); });
          } else if (v && typeof v === "object"){
            collect(v as JSONObject, p);
          }
        })
      }
    }

    collect(raw, []);

    // gom nh√≥m tr√πng key (n·∫øu c√≥) => merge items unique
    const merged = new Map<string, { title:string, items:Set<string>, key:string }>();
    out.forEach(g => {
      const exist = merged.get(g.key);
      if (!exist) merged.set(g.key, { title: g.title, items: new Set(g.items), key: g.key });
      else g.items.forEach(i=>exist.items.add(i));
    });
    return Array.from(merged.values()).map(m => ({ title: m.title, items: Array.from(m.items).sort(), key: m.key }));
  }, [raw]);

  const filteredGroups = useMemo(()=>{
    const q = query.trim().toLowerCase();
    const result = groups.filter(g => {
      if (onlySelected){
        const set = selections[g.key];
        if (!set || set.size===0) return false;
      }
      if (!q) return true;
      return g.title.toLowerCase().includes(q) || g.items.some(it=>it.toLowerCase().includes(q));
    });
    // s·∫Øp x·∫øp: nh√≥m c√≥ ch·ªçn n·ªïi l√™n tr∆∞·ªõc, sau ƒë√≥ theo t√™n
    return result.sort((a,b)=>{
      const sa = (selections[a.key]?.size||0); const sb = (selections[b.key]?.size||0);
      if (sa!==sb) return sb-sa;
      return a.title.localeCompare(b.title);
    })
  }, [groups, query, selections, onlySelected]);

  function toggleItem(groupKey: string, item: string, checked: boolean){
    setSelections(prev => {
      const copy: SelectionMap = { ...prev };
      const set = ensureSet(copy, groupKey);
      if (checked) set.add(item); else set.delete(item);
      return { ...copy };
    })
  }

  function selectAllInView(){
    setSelections(prev => {
      const copy: SelectionMap = { ...prev };
      filteredGroups.forEach(g => {
        const set = ensureSet(copy, g.key);
        g.items.forEach(it => set.add(it));
      });
      return { ...copy };
    })
  }

  function clearAll(){ setSelections({}); }

  const prompt = useMemo(()=>{
    const parts: string[] = [];
    filteredGroups // xu·∫•t theo to√†n b·ªô groups ban ƒë·∫ßu ƒë·ªÉ gi·ªØ tr·∫≠t t·ª± t·ª± nhi√™n
      ;
    (groups).forEach(g => {
      const chosen = selections[g.key];
      if (!chosen || chosen.size===0) return;
      const items = Array.from(chosen);
      const segment = showLabels ? `${g.title}: ${items.join(joiner)}` : items.join(joiner);
      parts.push(segment);
    })
    return parts.join("; ");
  }, [groups, selections, joiner, showLabels]);

  const tokenApprox = useMemo(()=>countTokensApprox(prompt), [prompt]);

  function copyPrompt(){
    navigator.clipboard.writeText(prompt).then(()=>{
      alert("ƒê√£ copy prompt v√†o Clipboard ‚úì");
    })
  }

  function savePreset(){
    const json = Object.fromEntries(Object.entries(selections).map(([k, s])=>[k, Array.from(s)]));
    const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'prompt-preset.json'; a.click();
    URL.revokeObjectURL(url);
  }

  function loadPresetFromFile(file: File){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const obj = JSON.parse(String(reader.result));
        const map: SelectionMap = Object.fromEntries(Object.entries(obj).map(([k, arr])=>[k, new Set(arr as string[])]));
        setSelections(map);
      } catch(e){ alert("T·ªáp preset kh√¥ng h·ª£p l·ªá."); }
    };
    reader.readAsText(file);
  }

  function importKeywordsFromFile(file: File){
    const reader = new FileReader();
    reader.onload = () => {
      try { setRaw(JSON.parse(String(reader.result))); setError(null); }
      catch(e){ alert("T·ªáp JSON kh√¥ng h·ª£p l·ªá."); }
    };
    reader.readAsText(file);
  }

  return (
    <div className="min-h-dvh bg-gradient-to-b from-white to-zinc-50 dark:from-zinc-950 dark:to-zinc-900 text-zinc-900 dark:text-zinc-100">
      <div className="max-w-7xl mx-auto px-4 py-6 md:py-10">
        <header className="flex flex-wrap items-center gap-4 mb-6">
          <h1 className="text-2xl md:text-3xl font-bold">Keyword Prompt Builder</h1>
          <Badge>ƒê·ªçc t·ª´: <code className="ml-1">keywords.json</code></Badge>
          {!!error && <span className="text-rose-600">(Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c t·ª± ƒë·ªông ‚Äî b·∫°n c√≥ th·ªÉ Import th·ªß c√¥ng)</span>}
          <div className="ml-auto flex items-center gap-2">
            <input placeholder="T√¨m nh√≥m/keyword..." value={query} onChange={e=>setQuery(e.target.value)} className="px-3 py-2 rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-transparent w-64" />
            <Button onClick={copyPrompt}>Copy Prompt</Button>
          </div>
        </header>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* C·ªôt tr√°i: c·∫•u h√¨nh & preview */}
          <div className="lg:col-span-1 space-y-4">
            <Card className="p-4 space-y-4">
              <h2 className="font-semibold">C·∫•u h√¨nh xu·∫•t prompt</h2>
              <Toolbar
                joiner={joiner}
                setJoiner={setJoiner}
                showLabels={showLabels}
                setShowLabels={setShowLabels}
                onlySelected={onlySelected}
                setOnlySelected={setOnlySelected}
                onClearAll={clearAll}
                onSelectAllInView={selectAllInView}
              />
            </Card>

            <Card className="p-4 space-y-3">
              <div className="flex items-center justify-between">
                <h2 className="font-semibold">Prompt preview</h2>
                <Badge>{tokenApprox} tokens ~ (∆∞·ªõc l∆∞·ª£ng)</Badge>
              </div>
              <textarea value={prompt} readOnly rows={10} className="w-full rounded-xl border border-zinc-200 dark:border-zinc-800 bg-transparent p-3 text-sm" />
              <div className="flex items-center gap-2">
                <Button onClick={copyPrompt}>Copy</Button>
                <Button className="bg-zinc-200 text-zinc-900 hover:bg-zinc-300" onClick={savePreset}>L∆∞u preset</Button>
                <label className="cursor-pointer px-3 py-2 rounded-2xl border border-zinc-200 dark:border-zinc-800">T·∫£i preset
                  <input hidden type="file" accept="application/json" onChange={e=>{const f=e.target.files?.[0]; if(f) loadPresetFromFile(f);}} />
                </label>
              </div>
            </Card>

            <Card className="p-4 space-y-3">
              <h2 className="font-semibold">Ngu·ªìn t·ª´ kho√°</h2>
              <p className="text-sm text-zinc-500">·ª®ng d·ª•ng s·∫Ω t·ª± t√¨m <code>./keywords.json</code>. N·∫øu kh√¥ng c√≥, b·∫°n c√≥ th·ªÉ nh·∫≠p file th·ªß c√¥ng.</p>
              <label className="cursor-pointer w-full text-center px-3 py-2 rounded-2xl border border-dashed border-zinc-300 dark:border-zinc-700 hover:bg-zinc-50 dark:hover:bg-zinc-900">Import keywords.json
                <input hidden type="file" accept="application/json" onChange={e=>{const f=e.target.files?.[0]; if(f) importKeywordsFromFile(f);}} />
              </label>
            </Card>
          </div>

          {/* C·ªôt ph·∫£i: danh s√°ch nh√≥m/keywords */}
          <div className="lg:col-span-2 space-y-4">
            {!raw && !error && (
              <Card className="p-6 text-center text-zinc-500">ƒêang t·∫£i <code>keywords.json</code>‚Ä¶</Card>
            )}

            {error && (
              <Card className="p-6 text-sm text-zinc-600 dark:text-zinc-300 space-y-2">
                <div className="font-semibold text-rose-600">Kh√¥ng th·ªÉ ƒë·ªçc ./keywords.json</div>
                <div>{error}</div>
                <div>H√£y ki·ªÉm tra t√™n t·ªáp, b·∫≠t server tƒ©nh, ho·∫∑c d√πng n√∫t <b>Import keywords.json</b> ·ªü c·ªôt tr√°i.</div>
              </Card>
            )}

            {filteredGroups.map(g => {
              const set = selections[g.key] || new Set<string>();
              const allChecked = set.size>0 && set.size===g.items.length;
              const someChecked = set.size>0 && set.size<g.items.length;
              return (
                <GroupBlock key={g.key} title={`${g.title} ${set.size?`(${set.size})`:""}`} defaultOpen={set.size>0}
                  right={
                    <div className="flex items-center gap-2">
                      {someChecked && <Badge>partial</Badge>}
                      <label className="flex items-center gap-2 text-sm">
                        <span>Ch·ªçn c·∫£ nh√≥m</span>
                        <Checkbox checked={allChecked} onChange={(v)=>{
                          setSelections(prev=>{
                            const copy: SelectionMap = { ...prev };
                            const s = ensureSet(copy, g.key);
                            if (v){ g.items.forEach(it=>s.add(it)); } else { s.clear(); }
                            return { ...copy };
                          })
                        }} />
                      </label>
                    </div>
                  }
                >
                  <ItemsGrid items={g.items} groupKey={g.key} selections={selections} onToggle={toggleItem} />
                </GroupBlock>
              )
            })}

            {filteredGroups.length===0 && (
              <Card className="p-6 text-center text-zinc-500">Kh√¥ng c√≥ nh√≥m n√†o ph√π h·ª£p v·ªõi t√¨m ki·∫øm ho·∫∑c b·ªô l·ªçc hi·ªán t·∫°i.</Card>
            )}
          </div>
        </div>

        <footer className="mt-10 text-center text-xs text-zinc-500">
          <div>Made with ‚ù§Ô∏è ‚Äì H·ªó tr·ª£ JSON l·ªìng s√¢u, ho·∫°t ƒë·ªông offline (sau khi t·∫£i).</div>
        </footer>
      </div>
    </div>
  );
}
